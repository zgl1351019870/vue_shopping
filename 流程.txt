1.划分项目结构
1.1 components下再创建两个文件夹，common和content，common主要放一些公共组件，就是一些任何项目想使用就可以直接拖过去的组件，重用性很高的，而content就放一些当前项目或者有业务逻辑的组件

2.引用两个css文件，normalize和base对css进行初始化

3.配置别名和编码习惯，需要自己手动在根目录下创建两个文件vue.config.js,.editorconfig

4.项目模块划分，完成tabbar，同时配置路由，ps：tabbar组件放在common中，展示tabbar的组件放在content中

----------------------------首页开发--------------------------------------------

5.封装导航组件，导航同样的放在common公共组件，每个页面都有导航栏，但是样式不同，我们就可以灵活使用插槽

6.安装axios，并配置好request，同时对每个页面的网络请求再进行一次封装，把home组件的所有网络请求都放到network下的home.js里，让home组件只负责处理结果then()

7.获取home首页的数据，当主页组件创建时，created钩子函数调用网络请求获得轮播图等的数据

8.封装轮播图组件banner，因为轮播图的复用性很高，明显的放到common公共组件里，由于轮播图是专属于主页的，所以把轮播图的展示代码放到home文件下的homechild文件中的homeswiper.vue中，这样home组件就只需要调用homeswiper组件就行了，注意我们在home组件获得的数据需要通过props传给homeswiper。

9.实现商品推荐模块recommend，因为商品推荐也专属于home，所以组件创建在homechild下，跟轮播图差不多

10.主页商品专栏home-feature，这个比较简单，因为就一张图，把他封装好，然后在home使用就行了

11.展示分类tabcontrol，因为其他组件可能会使用，而且是跟业务有关，所以放进content里。因为不同组件的小标题数量可能不同，所以不能写死，就需要home将标题数组title['流行','新款','精选']传进tabcontrol，然后遍历出来，因为tabcontrol采用弹性布局，所以如果title数组里面不止三个也可以不影响布局。然后是选中的css效果，动态绑定class，判断下标index是否与data中currentindex相同，有则有类active，然后点击事件，选中哪个标题就让currentindex等于index就好了

12.1商品展示，首先需要网络请求，在home.js里封装一个网络请求，这里要注意的是，商品展示的数据url是有两个参数的，type和page，所以在home组件中我们需要一个对象来存储数据，goods：{type:{page=0,list[]}},一个type就有page和list属性，每一页存放的数据放在list数组里，然后在mothods封装好函数，这里有个小技巧，因为page页数是动态的，不能写死，所以我们在methods中定义的函数可以只有参数type，来里面定义一个常量page然后再调用网络请求方法，每调用一次方法就让页数加一，并且将数据push到list数组末尾，最终请求过来的数据就可以保存到goods里了，然后将goods的list数据传给goodsList，v-for遍历，并将item（每个item就是list的每一个元素对象）再传入goodsListItem，最终在这里利用item展示每个数据，并且在home组件中的created钩子中调用三个标题的网络请求方法，这样三个标题的第一页的数据就保存完毕了

12.2结合tabcontrol，点击哪个标题就显示哪个标题的数据，首先在home组件data定义一个currenttype来存放当前的标题类型，给tabcontrol组件中发射一个自定义事件并且含有参数index，用switch语句，让每个index对应一个currenttype，然后通过计算属性来返回当前currenttype对应的goods的list并传给goodslist，这样商品的展示就完成啦

13.better-scroll重构滚动方式，首先npm install better-scroll --save，然后进行封装，很明显这里是封装进common里的，因为是公用组件，在scroll.vue中写好better-scroll的必须的模板后创建bscroll实例，然后进行一些配置，首先是click为true，这样基本的就实现了

14.返回顶部backtop的实现，首先是封装，放进content里，然后是样式啥的省略，然后要实现点击返回顶部，这里需要用到父组件访问子组件的方式$refs，我们给scroll组件设置ref属性scroll，然后我们就可以在home组件访问scroll的属性了，给backtop组件加点击事件，由于backtop是组件，事件需要添加native修饰符，在事件中设置this.$refs.scroll.scrollTo(0,0,500)就能返回顶部了，而且是500毫秒内返回。接着是让backtop组件在一定位置才出现，那就需要监听滚动的位置了，首先就需要给scroll添加probeType属性，当然不能写死（因为其他组件的值可能不一样），由home组件传过来的值来决定，当probeType的值为3，执行scroll事件并能获取position，将position配合自定义事件$emit发送给父组件home，然后给backtop一个v-show，当-position.y>1000时为true，这里要取负值，因为默认position.y是负值的。

15.better-scroll的bug解决：有时候因为请求数据时，scroll会根据content元素的子组件的高度设置滚动高度，而且只会获取一次，但是由于网速问题，图片可能还未加载出来，所以会出现计算的高度是错误的，导致滚动滚动不完整，因此我们需要监听图片加载事件，并且想办法让这个事件执行scroll自带的refresh方法来进行实时刷新，但是图片加载的组件时goodsListItem，他跟scroll的组件关系不是父子关系，要访问scroll的refresh方法就比较麻烦，这里可以使用vuex来进行状态管理，不过这里提供了一种新的知识-----事件总线

15.1.事件总线，跟vuex类似，不过是管理事件的，由于goodsListItem与scroll是非父子关系，要访问属性比较困难，当然，其实访问scroll的属性只需要到home组件这里就行了，但是goodsListItem跟home也隔了个goodsList。我们可以使用事件总线管理事件，首先我们在main.js那里给Vue添加一个原型$bus,并让其等于一个vue实例，因为每个vue实例都有$emit和$on方法，所以我们就可以在图片加载事件中利用this.$bus.emit()发射事件出去，注意这里的图片加载事件是用的vue自带的@load事件，然后在home组件那里的挂载钩子接收this.$bus.$on('',回调函数)在回调函数中执行refresh方法。这里可能会产生报错，这里涉及到生命周期的问题，但是目前讲不清楚，有可能会出现识别不了refs.scroll的情况，这里就加个判断就好了

15.2防抖的实现，如果不防抖，每次图片加载就执行刷新，那样频率就很高了，防抖的话还是比较简单的，这里省略了。因为防抖函数比较公用，这种工具型函数可以封装到common文件的untis.js里。

16.完成上拉加载更多，首先要监听首页是否上拉到最底端，我们需要给scroll设置pullUpLoad为true，当然pullUpLoad的值应该由首页传进来，然后给scroll设置pullingUp事件，在这里自定义事件发送到首页，在home里写方法，只需要在请求一次网络请求getHomeGoods()就好了。另外要注意的是，pullingUp默认只会执行一次，我们需要让他执行多次就需要
执行finishPullUp()。

17.tabControl的吸顶效果：获取offsetTop属性值，但是如果直接获取，一般值是错误的，因为图片可能还未加载出来，也就是高度还没有撑开时就获取了，因此我们需要监听图片的加载，一般我们只需要监听轮播图的图片就行了，因为首先轮播图的图片比较大，而且是网络请求出来的图片，所以我们可以以轮播图图片的加载完成来获取tabControl的offsetTop的值。这里要注意的是，轮播图只需要加载完一张就可以获取了，所以我们可以有几种方式让这个offsetTop只获取一次，简单的就是home组件接收homeSwiper传过来的自定义事件后，给事件加once修饰符即可，其他的方式看代码吧有注释。然后将获取到的offsetTop赋值给tabOffsetTop。

17.1获取完tabControl的offsetTop后，我们需要判断滚动到offsetTop这个位置时将tabControl转化为固定定位，在contentScroll方法中做判断-position.y大于offsetTop，正常来说我们可以给tabControl设置动态类，满足条件就修改为固定定位，但是这样在better-scroll有bug，也就是无法生效。因此我们可以换一种方式障眼法，也就是复制tabControl标签组件到scroll组件外，然后使用v-show来判断，超出offsetTop就显示，否则隐藏。同时注意两个tabControl的点击状态要同步。具体看代码

18.home内容保持原来位置，本来是挺简单的，只需要keep-alive就行了，但是better-scroll还是有bug。所以在keep-alive基础上，我们需要使用actived和deactived来记录不活跃时的位置，具体看代码

---------------------------------------------详情页开发----------------------------------------------------------
详情页很多都是根据主页的方式来的，这里提一些比较重要的知识点

1.评论展示中的时间戳转化为字符串，这里是直接拿封装好的时间转换函数使用的，里边最重要的是正则表达式，当然目前直接拿来用就好了。再有了这样一个函数后，当我们展示时间数据时可以使用过滤器，在过滤器中将时间戳转换为Date对象，注意这里时间戳要乘以1000，因为时间戳单位是秒，而date对象要传的参数是毫秒。然后将其作为时间转换函数的第一个参数返回，第二个参数就是要转换的格式。

2.在做这个页面中最经常遇见的问题其实也是跟better-scroll有关的，比如监听图片加载完成，有时也可以不用防抖，直接监听最后一张图片加载完成刷新refresh就行了，这是一种方案。

3.详情页有些组件中要展示的数据不一定是在同一个地方里面的，数据获取稍微比较复杂，我们可以进行一次封装，使用类或者构造函数的方式来创建对象，用这个对象存储组件要展示的数据

4.

